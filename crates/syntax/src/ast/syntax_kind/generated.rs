#![allow(bad_style, missing_docs, unreachable_pub)]
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Debug)]
#[repr(u16)]
pub enum SyntaxKind {
    /// --
    DECREMENT,
    /// /=
    SLASHEQ,
    /// ]
    R_BRACK,
    /// &
    AMP,
    /// *
    STAR,
    /// (
    L_PAREN,
    /// <<
    SHL,
    /// ~=
    TILDEEQ,
    /// >>>
    USHR,
    /// <<=
    SHLEQ,
    /// +=
    PLUSEQ,
    /// <=
    LTEQ,
    /// ==
    EQ2,
    /// ;
    SEMICOLON,
    /// <
    L_ANGLE,
    /// ...
    DOT3,
    /// [
    L_BRACK,
    /// -
    MINUS,
    /// |
    PIPE,
    /// >
    R_ANGLE,
    /// ~
    TILDE,
    /// )
    R_PAREN,
    /// !=
    NEQ,
    /// %
    PERCENT,
    /// ++
    INCREMENT,
    /// ::
    COLON2,
    /// >>=
    SHREQ,
    /// =
    EQ,
    /// ?
    QUESTION,
    /// &=
    AMPEQ,
    /// ^
    CARET,
    /// -=
    MINUSEQ,
    /// }
    R_CURLY,
    /// ||
    PIPE2,
    /// /
    SLASH,
    /// ^=
    CARETEQ,
    /// |=
    PIPEEQ,
    /// *=
    STAREQ,
    /// :
    COLON,
    /// >>
    SHR,
    /// +
    PLUS,
    /// .
    DOT,
    /// !
    BANG,
    /// &&
    AMP2,
    /// {
    L_CURLY,
    /// >=
    GTEQ,
    /// ,
    COMMA,
    /// bool,
    BOOL_KW,
    /// static,
    STATIC_KW,
    /// Float,
    OLD_FLOAT_KW,
    /// delete,
    DELETE_KW,
    /// else,
    ELSE_KW,
    /// false,
    FALSE_KW,
    /// get,
    GET_KW,
    /// case,
    CASE_KW,
    /// static_assert,
    STATIC_ASSERT_KW,
    /// native,
    NATIVE_KW,
    /// operator,
    OPERATOR_KW,
    /// typedef,
    TYPEDEF_KW,
    /// this,
    THIS_KW,
    /// stock,
    STOCK_KW,
    /// const,
    CONST_KW,
    /// forward,
    FORWARD_KW,
    /// true,
    TRUE_KW,
    /// return,
    RETURN_KW,
    /// property,
    PROPERTY_KW,
    /// while,
    WHILE_KW,
    /// set,
    SET_KW,
    /// function,
    FUNCTION_KW,
    /// defined,
    DEFINED_KW,
    /// if,
    IF_KW,
    /// continue,
    CONTINUE_KW,
    /// view_as,
    VIEW_AS_KW,
    /// typeset,
    TYPESET_KW,
    /// null,
    NULL_KW,
    /// new,
    NEW_KW,
    /// _,
    __KW,
    /// switch,
    SWITCH_KW,
    /// break,
    BREAK_KW,
    /// any,
    ANY_KW,
    /// functag,
    FUNCTAG_KW,
    /// methodmap,
    METHODMAP_KW,
    /// int,
    INT_KW,
    /// do,
    DO_KW,
    /// char,
    CHAR_KW,
    /// assert,
    ASSERT_KW,
    /// sizeof,
    SIZEOF_KW,
    /// decl,
    DECL_KW,
    /// enum,
    ENUM_KW,
    /// __nullable__,
    __NULLABLE___KW,
    /// String,
    OLD_STRING_KW,
    /// void,
    VOID_KW,
    /// public,
    PUBLIC_KW,
    /// default,
    DEFAULT_KW,
    /// float,
    FLOAT_KW,
    /// struct,
    STRUCT_KW,
    /// for,
    FOR_KW,
    /// funcenum,
    FUNCENUM_KW,
    /// #undef,
    PUNDEF,
    /// #error,
    PERROR,
    /// #warning,
    PWARNING,
    /// #else,
    PELSE,
    /// #assert,
    PASSERT,
    /// #tryinclude,
    PTRYINCLUDE,
    /// #pragma,
    PPRAGMA,
    /// #endif,
    PENDIF,
    /// #elseif,
    PELSEIF,
    /// #if,
    PIF,
    /// #include,
    PINCLUDE,
    /// #endinput,
    PENDINPUT,
    /// #define,
    PDEFINE,
    ARRAY_LITERAL,
    _LITERAL,
    BOOL_LITERAL,
    FLOAT_LITERAL,
    STRING_LITERAL,
    INT_LITERAL,
    CONCATENATED_STRING,
    NULL,
    CHAR_LITERAL,
    IDENT,
    SOURCE_FILE,
    _PREPROC_EXPRESSION,
    PREPROC_PARENTHESIZED_EXPRESSION,
    PREPROC_UNARY_EXPRESSION,
    PREPROC_BINARY_EXPRESSION,
    PREPROC_INCLUDE,
    PREPROC_TRYINCLUDE,
    PREPROC_MACRO,
    MACRO_PARAM,
    PREPROC_DEFINE,
    PREPROC_UNDEFINE,
    PREPROC_IF,
    PREPROC_ELSEIF,
    PREPROC_ASSERT,
    PREPROC_DEFINED_CONDITION,
    PREPROC_ELSE,
    PREPROC_ENDIF,
    PREPROC_ENDINPUT,
    PREPROC_PRAGMA,
    PREPROC_ERROR,
    PREPROC_WARNING,
    HARDCODED_SYMBOL,
    ASSERTION,
    FUNCTION_DECLARATION,
    FUNCTION_VISIBILITY,
    FUNCTION_DEFINITION,
    FUNCTION_DEFINITION_TYPE,
    ARGUMENT_DECLARATIONS,
    ARGUMENT_TYPE,
    ARGUMENT_DECLARATION,
    REST_ARGUMENT,
    ALIAS_OPERATOR,
    ALIAS_DECLARATION,
    ALIAS_ASSIGNMENT,
    GLOBAL_VARIABLE_DECLARATION,
    VARIABLE_DECLARATION_STATEMENT,
    VARIABLE_STORAGE_CLASS,
    VARIABLE_VISIBILITY,
    VARIABLE_DECLARATION,
    DYNAMIC_ARRAY,
    NEW_INSTANCE,
    OLD_GLOBAL_VARIABLE_DECLARATION,
    OLD_VARIABLE_DECLARATION_STATEMENT,
    OLD_VARIABLE_DECLARATION,
    ENUM,
    ENUM_ENTRIES,
    ENUM_ENTRY,
    ENUM_STRUCT,
    ENUM_STRUCT_FIELD,
    ENUM_STRUCT_METHOD,
    TYPEDEF,
    TYPESET,
    TYPEDEF_EXPRESSION,
    FUNCENUM,
    FUNCENUM_MEMBER,
    FUNCTAG,
    METHODMAP,
    METHODMAP_ALIAS,
    METHODMAP_NATIVE,
    METHODMAP_NATIVE_CONSTRUCTOR,
    METHODMAP_NATIVE_DESTRUCTOR,
    METHODMAP_METHOD,
    METHODMAP_METHOD_CONSTRUCTOR,
    METHODMAP_METHOD_DESTRUCTOR,
    METHODMAP_PROPERTY,
    METHODMAP_PROPERTY_ALIAS,
    METHODMAP_PROPERTY_NATIVE,
    METHODMAP_PROPERTY_METHOD,
    METHODMAP_PROPERTY_GETTER,
    METHODMAP_PROPERTY_SETTER,
    METHODMAP_VISIBILITY,
    STRUCT,
    STRUCT_FIELD,
    STRUCT_DECLARATION,
    STRUCT_CONSTRUCTOR,
    STRUCT_FIELD_VALUE,
    TYPE,
    OLD_TYPE,
    DIMENSION,
    FIXED_DIMENSION,
    BUILTIN_TYPE,
    OLD_BUILTIN_TYPE,
    ANY_TYPE,
    BLOCK,
    _STATEMENT,
    FOR_STATEMENT,
    WHILE_STATEMENT,
    DO_WHILE_STATEMENT,
    BREAK_STATEMENT,
    CONTINUE_STATEMENT,
    CONDITION_STATEMENT,
    SWITCH_STATEMENT,
    SWITCH_CASE,
    SWITCH_CASE_VALUES,
    SWITCH_DEFAULT_CASE,
    EXPRESSION_STATEMENT,
    RETURN_STATEMENT,
    DELETE_STATEMENT,
    _MANUAL_SEMICOLON,
    _SEMICOLON,
    _EXPRESSION,
    ASSIGNMENT_EXPRESSION,
    FUNCTION_CALL,
    FUNCTION_CALL_ARGUMENTS,
    NAMED_ARG,
    IGNORE_ARGUMENT,
    ARRAY_INDEXED_ACCESS,
    PARENTHESIZED_EXPRESSION,
    COMMA_EXPRESSION,
    TERNARY_EXPRESSION,
    FIELD_ACCESS,
    SCOPE_ACCESS,
    UNARY_EXPRESSION,
    BINARY_EXPRESSION,
    UPDATE_EXPRESSION,
    _SIZEOF_CALL_EXPRESSION,
    ARRAY_SCOPE_ACCESS,
    SIZEOF_EXPRESSION,
    VIEW_AS,
    OLD_TYPE_CAST,
    ESCAPE_SEQUENCE,
    THIS,
    REST_OPERATOR,
    SYSTEM_LIB_STRING,
    SYMBOL,
    COMMENT,
    HARDCODED,
// Technical kind so that we can cast from u16 safely
    #[doc(hidden)]
    __LAST,
}

#[macro_export]
macro_rules ! T {[--] => { $ crate::SyntaxKind::DECREMENT } ; [/=] => { $ crate::SyntaxKind::SLASHEQ } ; [']'] => { $ crate::SyntaxKind::R_BRACK } ; [&] => { $ crate::SyntaxKind::AMP } ; [*] => { $ crate::SyntaxKind::STAR } ; ['('] => { $ crate::SyntaxKind::L_PAREN } ; [<<] => { $ crate::SyntaxKind::SHL } ; [~=] => { $ crate::SyntaxKind::TILDEEQ } ; [>>>] => { $ crate::SyntaxKind::USHR } ; [<<=] => { $ crate::SyntaxKind::SHLEQ } ; [+=] => { $ crate::SyntaxKind::PLUSEQ } ; [<=] => { $ crate::SyntaxKind::LTEQ } ; [==] => { $ crate::SyntaxKind::EQ2 } ; [;] => { $ crate::SyntaxKind::SEMICOLON } ; [<] => { $ crate::SyntaxKind::L_ANGLE } ; [...] => { $ crate::SyntaxKind::DOT3 } ; ['['] => { $ crate::SyntaxKind::L_BRACK } ; [-] => { $ crate::SyntaxKind::MINUS } ; [|] => { $ crate::SyntaxKind::PIPE } ; [>] => { $ crate::SyntaxKind::R_ANGLE } ; [~] => { $ crate::SyntaxKind::TILDE } ; [')'] => { $ crate::SyntaxKind::R_PAREN } ; [!=] => { $ crate::SyntaxKind::NEQ } ; [%] => { $ crate::SyntaxKind::PERCENT } ; [++] => { $ crate::SyntaxKind::INCREMENT } ; [::] => { $ crate::SyntaxKind::COLON2 } ; [>>=] => { $ crate::SyntaxKind::SHREQ } ; [=] => { $ crate::SyntaxKind::EQ } ; [?] => { $ crate::SyntaxKind::QUESTION } ; [&=] => { $ crate::SyntaxKind::AMPEQ } ; [^] => { $ crate::SyntaxKind::CARET } ; [-=] => { $ crate::SyntaxKind::MINUSEQ } ; ['}'] => { $ crate::SyntaxKind::R_CURLY } ; [||] => { $ crate::SyntaxKind::PIPE2 } ; [/] => { $ crate::SyntaxKind::SLASH } ; [^=] => { $ crate::SyntaxKind::CARETEQ } ; [|=] => { $ crate::SyntaxKind::PIPEEQ } ; [*=] => { $ crate::SyntaxKind::STAREQ } ; [:] => { $ crate::SyntaxKind::COLON } ; [>>] => { $ crate::SyntaxKind::SHR } ; [+] => { $ crate::SyntaxKind::PLUS } ; [.] => { $ crate::SyntaxKind::DOT } ; [!] => { $ crate::SyntaxKind::BANG } ; [&&] => { $ crate::SyntaxKind::AMP2 } ; ['{'] => { $ crate::SyntaxKind::L_CURLY } ; [>=] => { $ crate::SyntaxKind::GTEQ } ; [,] => { $ crate::SyntaxKind::COMMA } ; [bool] => { $ crate::SyntaxKind::BOOL_KW } ; [static] => { $ crate::SyntaxKind::STATIC_KW } ; [Float] => { $ crate::SyntaxKind::OLD_FLOAT_KW } ; [delete] => { $ crate::SyntaxKind::DELETE_KW } ; [else] => { $ crate::SyntaxKind::ELSE_KW } ; [false] => { $ crate::SyntaxKind::FALSE_KW } ; [get] => { $ crate::SyntaxKind::GET_KW } ; [case] => { $ crate::SyntaxKind::CASE_KW } ; [static_assert] => { $ crate::SyntaxKind::STATIC_ASSERT_KW } ; [native] => { $ crate::SyntaxKind::NATIVE_KW } ; [operator] => { $ crate::SyntaxKind::OPERATOR_KW } ; [typedef] => { $ crate::SyntaxKind::TYPEDEF_KW } ; [this] => { $ crate::SyntaxKind::THIS_KW } ; [stock] => { $ crate::SyntaxKind::STOCK_KW } ; [const] => { $ crate::SyntaxKind::CONST_KW } ; [forward] => { $ crate::SyntaxKind::FORWARD_KW } ; [true] => { $ crate::SyntaxKind::TRUE_KW } ; [return] => { $ crate::SyntaxKind::RETURN_KW } ; [property] => { $ crate::SyntaxKind::PROPERTY_KW } ; [while] => { $ crate::SyntaxKind::WHILE_KW } ; [set] => { $ crate::SyntaxKind::SET_KW } ; [function] => { $ crate::SyntaxKind::FUNCTION_KW } ; [defined] => { $ crate::SyntaxKind::DEFINED_KW } ; [if] => { $ crate::SyntaxKind::IF_KW } ; [continue] => { $ crate::SyntaxKind::CONTINUE_KW } ; [view_as] => { $ crate::SyntaxKind::VIEW_AS_KW } ; [typeset] => { $ crate::SyntaxKind::TYPESET_KW } ; [null] => { $ crate::SyntaxKind::NULL_KW } ; [new] => { $ crate::SyntaxKind::NEW_KW } ; [_] => { $ crate::SyntaxKind::__KW } ; [switch] => { $ crate::SyntaxKind::SWITCH_KW } ; [break] => { $ crate::SyntaxKind::BREAK_KW } ; [any] => { $ crate::SyntaxKind::ANY_KW } ; [functag] => { $ crate::SyntaxKind::FUNCTAG_KW } ; [methodmap] => { $ crate::SyntaxKind::METHODMAP_KW } ; [int] => { $ crate::SyntaxKind::INT_KW } ; [do] => { $ crate::SyntaxKind::DO_KW } ; [char] => { $ crate::SyntaxKind::CHAR_KW } ; [assert] => { $ crate::SyntaxKind::ASSERT_KW } ; [sizeof] => { $ crate::SyntaxKind::SIZEOF_KW } ; [decl] => { $ crate::SyntaxKind::DECL_KW } ; [enum] => { $ crate::SyntaxKind::ENUM_KW } ; [__nullable__] => { $ crate::SyntaxKind::__NULLABLE___KW } ; [String] => { $ crate::SyntaxKind::OLD_STRING_KW } ; [void] => { $ crate::SyntaxKind::VOID_KW } ; [public] => { $ crate::SyntaxKind::PUBLIC_KW } ; [default] => { $ crate::SyntaxKind::DEFAULT_KW } ; [float] => { $ crate::SyntaxKind::FLOAT_KW } ; [struct] => { $ crate::SyntaxKind::STRUCT_KW } ; [for] => { $ crate::SyntaxKind::FOR_KW } ; [funcenum] => { $ crate::SyntaxKind::FUNCENUM_KW } ; [pundef] => { $ crate::SyntaxKind::PUNDEF } ; [perror] => { $ crate::SyntaxKind::PERROR } ; [pwarning] => { $ crate::SyntaxKind::PWARNING } ; [pelse] => { $ crate::SyntaxKind::PELSE } ; [passert] => { $ crate::SyntaxKind::PASSERT } ; [ptryinclude] => { $ crate::SyntaxKind::PTRYINCLUDE } ; [ppragma] => { $ crate::SyntaxKind::PPRAGMA } ; [pendif] => { $ crate::SyntaxKind::PENDIF } ; [pelseif] => { $ crate::SyntaxKind::PELSEIF } ; [pif] => { $ crate::SyntaxKind::PIF } ; [pinclude] => { $ crate::SyntaxKind::PINCLUDE } ; [pendinput] => { $ crate::SyntaxKind::PENDINPUT } ; [pdefine] => { $ crate::SyntaxKind::PDEFINE } ; [hardcoded] => { $ crate::SyntaxKind::HARDCODED } ; [IDENT] => { $ crate::SyntaxKind::IDENT }}
pub use T;