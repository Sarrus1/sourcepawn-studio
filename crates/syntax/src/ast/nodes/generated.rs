//! Generated by `sourcegen_ast`, do not edit by hand.

#![allow(non_snake_case)]
use crate::{
    ast::{self, support, AstChildren, AstNode},
    SyntaxKind::{self, *},
    SyntaxNode, SyntaxToken, T,
};
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct SourceFile {
    pub(crate) syntax: SyntaxNode,
}
impl SourceFile {}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct PreprocExpression {
    pub(crate) syntax: SyntaxNode,
}
impl PreprocExpression {}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct PreprocParenthesizedExpression {
    pub(crate) syntax: SyntaxNode,
}
impl PreprocParenthesizedExpression {
    pub fn l_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['('])
    }
    pub fn r_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![')'])
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct PreprocUnaryExpression {
    pub(crate) syntax: SyntaxNode,
}
impl PreprocUnaryExpression {}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct PreprocBinaryExpression {
    pub(crate) syntax: SyntaxNode,
}
impl PreprocBinaryExpression {}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct PreprocInclude {
    pub(crate) syntax: SyntaxNode,
}
impl PreprocInclude {
    pub fn pinclude_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![pinclude])
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct PreprocTryinclude {
    pub(crate) syntax: SyntaxNode,
}
impl PreprocTryinclude {
    pub fn ptryinclude_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![ptryinclude])
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct PreprocMacro {
    pub(crate) syntax: SyntaxNode,
}
impl PreprocMacro {}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct MacroParam {
    pub(crate) syntax: SyntaxNode,
}
impl MacroParam {}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct PreprocDefine {
    pub(crate) syntax: SyntaxNode,
}
impl PreprocDefine {
    pub fn pdefine_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![pdefine])
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct PreprocUndefine {
    pub(crate) syntax: SyntaxNode,
}
impl PreprocUndefine {
    pub fn pundef_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![pundef])
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct PreprocIf {
    pub(crate) syntax: SyntaxNode,
}
impl PreprocIf {
    pub fn pif_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![pif])
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct PreprocElseif {
    pub(crate) syntax: SyntaxNode,
}
impl PreprocElseif {
    pub fn pelseif_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![pelseif])
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct PreprocAssert {
    pub(crate) syntax: SyntaxNode,
}
impl PreprocAssert {
    pub fn passert_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![passert])
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct PreprocDefinedCondition {
    pub(crate) syntax: SyntaxNode,
}
impl PreprocDefinedCondition {
    pub fn defined_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![defined])
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct PreprocElse {
    pub(crate) syntax: SyntaxNode,
}
impl PreprocElse {}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct PreprocEndif {
    pub(crate) syntax: SyntaxNode,
}
impl PreprocEndif {}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct PreprocEndinput {
    pub(crate) syntax: SyntaxNode,
}
impl PreprocEndinput {}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct PreprocPragma {
    pub(crate) syntax: SyntaxNode,
}
impl PreprocPragma {
    pub fn ppragma_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![ppragma])
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct PreprocError {
    pub(crate) syntax: SyntaxNode,
}
impl PreprocError {
    pub fn perror_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![perror])
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct PreprocWarning {
    pub(crate) syntax: SyntaxNode,
}
impl PreprocWarning {
    pub fn pwarning_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![pwarning])
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct HardcodedSymbol {
    pub(crate) syntax: SyntaxNode,
}
impl HardcodedSymbol {
    pub fn hardcoded_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![hardcoded])
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Assertion {
    pub(crate) syntax: SyntaxNode,
}
impl Assertion {}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct FunctionDeclaration {
    pub(crate) syntax: SyntaxNode,
}
impl FunctionDeclaration {}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct FunctionVisibility {
    pub(crate) syntax: SyntaxNode,
}
impl FunctionVisibility {
    pub fn public_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![public])
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct FunctionDefinition {
    pub(crate) syntax: SyntaxNode,
}
impl FunctionDefinition {}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct FunctionDefinitionType {
    pub(crate) syntax: SyntaxNode,
}
impl FunctionDefinitionType {
    pub fn forward_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![forward])
    }
    pub fn native_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![native])
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ArgumentDeclarations {
    pub(crate) syntax: SyntaxNode,
}
impl ArgumentDeclarations {
    pub fn l_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['('])
    }
    pub fn r_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![')'])
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ArgumentType {
    pub(crate) syntax: SyntaxNode,
}
impl ArgumentType {
    pub fn amp_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![&])
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ArgumentDeclaration {
    pub(crate) syntax: SyntaxNode,
}
impl ArgumentDeclaration {}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct RestArgument {
    pub(crate) syntax: SyntaxNode,
}
impl RestArgument {
    pub fn dot3_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![...])
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct AliasOperator {
    pub(crate) syntax: SyntaxNode,
}
impl AliasOperator {}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct AliasDeclaration {
    pub(crate) syntax: SyntaxNode,
}
impl AliasDeclaration {
    pub fn operator_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![operator])
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct AliasAssignment {
    pub(crate) syntax: SyntaxNode,
}
impl AliasAssignment {}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct GlobalVariableDeclaration {
    pub(crate) syntax: SyntaxNode,
}
impl GlobalVariableDeclaration {}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct VariableDeclarationStatement {
    pub(crate) syntax: SyntaxNode,
}
impl VariableDeclarationStatement {}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct VariableStorageClass {
    pub(crate) syntax: SyntaxNode,
}
impl VariableStorageClass {
    pub fn static_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![static])
    }
    pub fn const_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![const])
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct VariableVisibility {
    pub(crate) syntax: SyntaxNode,
}
impl VariableVisibility {
    pub fn public_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![public])
    }
    pub fn stock_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![stock])
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct VariableDeclaration {
    pub(crate) syntax: SyntaxNode,
}
impl VariableDeclaration {}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct DynamicArray {
    pub(crate) syntax: SyntaxNode,
}
impl DynamicArray {
    pub fn new_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![new])
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct NewInstance {
    pub(crate) syntax: SyntaxNode,
}
impl NewInstance {
    pub fn new_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![new])
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct OldGlobalVariableDeclaration {
    pub(crate) syntax: SyntaxNode,
}
impl OldGlobalVariableDeclaration {}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct OldVariableDeclarationStatement {
    pub(crate) syntax: SyntaxNode,
}
impl OldVariableDeclarationStatement {}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct OldVariableDeclaration {
    pub(crate) syntax: SyntaxNode,
}
impl OldVariableDeclaration {}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Enum {
    pub(crate) syntax: SyntaxNode,
}
impl Enum {
    pub fn enum_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![enum])
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct EnumEntries {
    pub(crate) syntax: SyntaxNode,
}
impl EnumEntries {
    pub fn l_curly_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['{'])
    }
    pub fn r_curly_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['}'])
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct EnumEntry {
    pub(crate) syntax: SyntaxNode,
}
impl EnumEntry {}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct EnumStruct {
    pub(crate) syntax: SyntaxNode,
}
impl EnumStruct {
    pub fn enum_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![enum])
    }
    pub fn struct_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![struct])
    }
    pub fn l_curly_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['{'])
    }
    pub fn r_curly_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['}'])
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct EnumStructField {
    pub(crate) syntax: SyntaxNode,
}
impl EnumStructField {}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct EnumStructMethod {
    pub(crate) syntax: SyntaxNode,
}
impl EnumStructMethod {}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Typedef {
    pub(crate) syntax: SyntaxNode,
}
impl Typedef {
    pub fn typedef_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![typedef])
    }
    pub fn eq_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![=])
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Typeset {
    pub(crate) syntax: SyntaxNode,
}
impl Typeset {
    pub fn typeset_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![typeset])
    }
    pub fn l_curly_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['{'])
    }
    pub fn r_curly_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['}'])
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct TypedefExpression {
    pub(crate) syntax: SyntaxNode,
}
impl TypedefExpression {}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Funcenum {
    pub(crate) syntax: SyntaxNode,
}
impl Funcenum {
    pub fn funcenum_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![funcenum])
    }
    pub fn l_curly_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['{'])
    }
    pub fn r_curly_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['}'])
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct FuncenumMember {
    pub(crate) syntax: SyntaxNode,
}
impl FuncenumMember {
    pub fn public_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![public])
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Functag {
    pub(crate) syntax: SyntaxNode,
}
impl Functag {}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Methodmap {
    pub(crate) syntax: SyntaxNode,
}
impl Methodmap {
    pub fn methodmap_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![methodmap])
    }
    pub fn l_curly_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['{'])
    }
    pub fn r_curly_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['}'])
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct MethodmapAlias {
    pub(crate) syntax: SyntaxNode,
}
impl MethodmapAlias {
    pub fn l_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['('])
    }
    pub fn r_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![')'])
    }
    pub fn eq_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![=])
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct MethodmapNative {
    pub(crate) syntax: SyntaxNode,
}
impl MethodmapNative {
    pub fn native_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![native])
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct MethodmapNativeConstructor {
    pub(crate) syntax: SyntaxNode,
}
impl MethodmapNativeConstructor {
    pub fn native_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![native])
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct MethodmapNativeDestructor {
    pub(crate) syntax: SyntaxNode,
}
impl MethodmapNativeDestructor {
    pub fn native_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![native])
    }
    pub fn tilde_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![~])
    }
    pub fn l_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['('])
    }
    pub fn r_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![')'])
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct MethodmapMethod {
    pub(crate) syntax: SyntaxNode,
}
impl MethodmapMethod {}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct MethodmapMethodConstructor {
    pub(crate) syntax: SyntaxNode,
}
impl MethodmapMethodConstructor {}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct MethodmapMethodDestructor {
    pub(crate) syntax: SyntaxNode,
}
impl MethodmapMethodDestructor {
    pub fn tilde_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![~])
    }
    pub fn l_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['('])
    }
    pub fn r_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![')'])
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct MethodmapProperty {
    pub(crate) syntax: SyntaxNode,
}
impl MethodmapProperty {
    pub fn property_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![property])
    }
    pub fn l_curly_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['{'])
    }
    pub fn r_curly_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['}'])
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct MethodmapPropertyAlias {
    pub(crate) syntax: SyntaxNode,
}
impl MethodmapPropertyAlias {
    pub fn eq_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![=])
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct MethodmapPropertyNative {
    pub(crate) syntax: SyntaxNode,
}
impl MethodmapPropertyNative {
    pub fn native_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![native])
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct MethodmapPropertyMethod {
    pub(crate) syntax: SyntaxNode,
}
impl MethodmapPropertyMethod {}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct MethodmapPropertyGetter {
    pub(crate) syntax: SyntaxNode,
}
impl MethodmapPropertyGetter {
    pub fn get_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![get])
    }
    pub fn l_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['('])
    }
    pub fn r_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![')'])
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct MethodmapPropertySetter {
    pub(crate) syntax: SyntaxNode,
}
impl MethodmapPropertySetter {
    pub fn set_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![set])
    }
    pub fn l_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['('])
    }
    pub fn r_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![')'])
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct MethodmapVisibility {
    pub(crate) syntax: SyntaxNode,
}
impl MethodmapVisibility {}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Struct {
    pub(crate) syntax: SyntaxNode,
}
impl Struct {
    pub fn struct_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![struct])
    }
    pub fn l_curly_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['{'])
    }
    pub fn r_curly_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['}'])
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct StructField {
    pub(crate) syntax: SyntaxNode,
}
impl StructField {
    pub fn public_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![public])
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct StructDeclaration {
    pub(crate) syntax: SyntaxNode,
}
impl StructDeclaration {
    pub fn public_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![public])
    }
    pub fn eq_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![=])
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct StructConstructor {
    pub(crate) syntax: SyntaxNode,
}
impl StructConstructor {
    pub fn l_curly_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['{'])
    }
    pub fn r_curly_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['}'])
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct StructFieldValue {
    pub(crate) syntax: SyntaxNode,
}
impl StructFieldValue {
    pub fn eq_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![=])
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Type {
    pub(crate) syntax: SyntaxNode,
}
impl Type {}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct OldType {
    pub(crate) syntax: SyntaxNode,
}
impl OldType {}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Dimension {
    pub(crate) syntax: SyntaxNode,
}
impl Dimension {
    pub fn l_brack_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['['])
    }
    pub fn r_brack_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![']'])
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct FixedDimension {
    pub(crate) syntax: SyntaxNode,
}
impl FixedDimension {
    pub fn l_brack_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['['])
    }
    pub fn r_brack_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![']'])
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct BuiltinType {
    pub(crate) syntax: SyntaxNode,
}
impl BuiltinType {
    pub fn void_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![void])
    }
    pub fn bool_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![bool])
    }
    pub fn int_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![int])
    }
    pub fn float_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![float])
    }
    pub fn char_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![char])
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct OldBuiltinType {
    pub(crate) syntax: SyntaxNode,
}
impl OldBuiltinType {
    pub fn underscore_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![_])
    }
    pub fn Float_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![Float])
    }
    pub fn bool_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![bool])
    }
    pub fn String_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![String])
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct AnyType {
    pub(crate) syntax: SyntaxNode,
}
impl AnyType {}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Block {
    pub(crate) syntax: SyntaxNode,
}
impl Block {
    pub fn l_curly_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['{'])
    }
    pub fn r_curly_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['}'])
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Statement {
    pub(crate) syntax: SyntaxNode,
}
impl Statement {}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ForStatement {
    pub(crate) syntax: SyntaxNode,
}
impl ForStatement {
    pub fn for_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![for])
    }
    pub fn l_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['('])
    }
    pub fn r_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![')'])
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct WhileStatement {
    pub(crate) syntax: SyntaxNode,
}
impl WhileStatement {
    pub fn while_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![while])
    }
    pub fn l_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['('])
    }
    pub fn r_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![')'])
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct DoWhileStatement {
    pub(crate) syntax: SyntaxNode,
}
impl DoWhileStatement {}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct BreakStatement {
    pub(crate) syntax: SyntaxNode,
}
impl BreakStatement {}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ContinueStatement {
    pub(crate) syntax: SyntaxNode,
}
impl ContinueStatement {}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ConditionStatement {
    pub(crate) syntax: SyntaxNode,
}
impl ConditionStatement {}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct SwitchStatement {
    pub(crate) syntax: SyntaxNode,
}
impl SwitchStatement {
    pub fn switch_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![switch])
    }
    pub fn l_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['('])
    }
    pub fn r_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![')'])
    }
    pub fn l_curly_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['{'])
    }
    pub fn r_curly_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['}'])
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct SwitchCase {
    pub(crate) syntax: SyntaxNode,
}
impl SwitchCase {
    pub fn case_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![case])
    }
    pub fn colon_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![:])
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct SwitchCaseValues {
    pub(crate) syntax: SyntaxNode,
}
impl SwitchCaseValues {}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct SwitchDefaultCase {
    pub(crate) syntax: SyntaxNode,
}
impl SwitchDefaultCase {
    pub fn default_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![default])
    }
    pub fn colon_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![:])
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ExpressionStatement {
    pub(crate) syntax: SyntaxNode,
}
impl ExpressionStatement {}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ReturnStatement {
    pub(crate) syntax: SyntaxNode,
}
impl ReturnStatement {}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct DeleteStatement {
    pub(crate) syntax: SyntaxNode,
}
impl DeleteStatement {}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ManualSemicolon {
    pub(crate) syntax: SyntaxNode,
}
impl ManualSemicolon {}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Semicolon {
    pub(crate) syntax: SyntaxNode,
}
impl Semicolon {}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Expression {
    pub(crate) syntax: SyntaxNode,
}
impl Expression {}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct AssignmentExpression {
    pub(crate) syntax: SyntaxNode,
}
impl AssignmentExpression {}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct FunctionCall {
    pub(crate) syntax: SyntaxNode,
}
impl FunctionCall {}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct FunctionCallArguments {
    pub(crate) syntax: SyntaxNode,
}
impl FunctionCallArguments {}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct NamedArg {
    pub(crate) syntax: SyntaxNode,
}
impl NamedArg {
    pub fn dot_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![.])
    }
    pub fn eq_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![=])
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct IgnoreArgument {
    pub(crate) syntax: SyntaxNode,
}
impl IgnoreArgument {}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ArrayIndexedAccess {
    pub(crate) syntax: SyntaxNode,
}
impl ArrayIndexedAccess {}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ParenthesizedExpression {
    pub(crate) syntax: SyntaxNode,
}
impl ParenthesizedExpression {
    pub fn l_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['('])
    }
    pub fn r_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![')'])
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct CommaExpression {
    pub(crate) syntax: SyntaxNode,
}
impl CommaExpression {
    pub fn comma_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![,])
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct TernaryExpression {
    pub(crate) syntax: SyntaxNode,
}
impl TernaryExpression {}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct FieldAccess {
    pub(crate) syntax: SyntaxNode,
}
impl FieldAccess {}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ScopeAccess {
    pub(crate) syntax: SyntaxNode,
}
impl ScopeAccess {}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct UnaryExpression {
    pub(crate) syntax: SyntaxNode,
}
impl UnaryExpression {}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct BinaryExpression {
    pub(crate) syntax: SyntaxNode,
}
impl BinaryExpression {}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct UpdateExpression {
    pub(crate) syntax: SyntaxNode,
}
impl UpdateExpression {}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct SizeofCallExpression {
    pub(crate) syntax: SyntaxNode,
}
impl SizeofCallExpression {}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ArrayScopeAccess {
    pub(crate) syntax: SyntaxNode,
}
impl ArrayScopeAccess {}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct SizeofExpression {
    pub(crate) syntax: SyntaxNode,
}
impl SizeofExpression {}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ViewAs {
    pub(crate) syntax: SyntaxNode,
}
impl ViewAs {
    pub fn view_as_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![view_as])
    }
    pub fn l_angle_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![<])
    }
    pub fn r_angle_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![>])
    }
    pub fn l_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['('])
    }
    pub fn r_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![')'])
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct OldTypeCast {
    pub(crate) syntax: SyntaxNode,
}
impl OldTypeCast {}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct EscapeSequence {
    pub(crate) syntax: SyntaxNode,
}
impl EscapeSequence {}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct This {
    pub(crate) syntax: SyntaxNode,
}
impl This {}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct RestOperator {
    pub(crate) syntax: SyntaxNode,
}
impl RestOperator {}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct SystemLibString {
    pub(crate) syntax: SyntaxNode,
}
impl SystemLibString {}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Symbol {
    pub(crate) syntax: SyntaxNode,
}
impl Symbol {}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Comment {
    pub(crate) syntax: SyntaxNode,
}
impl Comment {}
